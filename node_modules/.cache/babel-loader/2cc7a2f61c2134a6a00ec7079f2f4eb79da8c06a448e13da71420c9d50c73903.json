{"ast":null,"code":"import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\nimport { createUtil } from './simplify/util.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  var {\n    hasProperty,\n    isCommutative\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     simplify, resolve, derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   * @param {Object} options\n   *     Simplification options, as per simplify()\n   * @return {Node} Returns expression with basic simplifications applied\n   */\n\n  function simplifyCore(node, options) {\n    var context = options ? options.context : undefined;\n    if (hasProperty(node, 'trivial', context)) {\n      // This node does nothing if it has only one argument, so if so,\n      // return that argument simplified\n      if (isFunctionNode(node) && node.args.length === 1) {\n        return simplifyCore(node.args[0], options);\n      } // For other node types, we try the generic methods\n\n      var simpChild = false;\n      var childCount = 0;\n      node.forEach(c => {\n        ++childCount;\n        if (childCount === 1) {\n          simpChild = simplifyCore(c, options);\n        }\n      });\n      if (childCount === 1) {\n        return simpChild;\n      }\n    }\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0], options);\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0], options);\n      var a1 = simplifyCore(node.args[1], options);\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]), options);\n          }\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op && isCommutative(node, context)) {\n            var a00 = _a.args[0];\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          if (isCommutative(node, context)) {\n            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n          } else {\n            return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n          }\n        }\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n      }\n      return new OperatorNode(node.op, node.fn, [_a, a1]);\n    } else if (isFunctionNode(node)) {\n      return new FunctionNode(simplifyCore(node.fn), node.args.map(n => simplifyCore(n, options)));\n    } else if (isArrayNode(node)) {\n      return new ArrayNode(node.items.map(n => simplifyCore(n, options)));\n    } else if (isAccessorNode(node)) {\n      return new AccessorNode(simplifyCore(node.object, options), simplifyCore(node.index, options));\n    } else if (isIndexNode(node)) {\n      return new IndexNode(node.dimensions.map(n => simplifyCore(n, options)));\n    } else if (isObjectNode(node)) {\n      var newProps = {};\n      for (var prop in node.properties) {\n        newProps[prop] = simplifyCore(node.properties[prop], options);\n      }\n      return new ObjectNode(newProps);\n    } else {// cannot simplify\n    }\n    return node;\n  }\n  return simplifyCore;\n});","map":{"version":3,"names":["isAccessorNode","isArrayNode","isConstantNode","isFunctionNode","isIndexNode","isObjectNode","isOperatorNode","createUtil","factory","name","dependencies","createSimplifyCore","_ref","equal","isZero","add","subtract","multiply","divide","pow","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","SymbolNode","node0","node1","hasProperty","isCommutative","simplifyCore","node","options","context","undefined","args","length","simpChild","childCount","forEach","c","isUnary","a0","op","isBinary","fn","_a","a1","value","a00","a00a1","implicit","a01","map","n","items","object","index","dimensions","newProps","prop","properties"],"sources":["/Users/front-end-projects/websites/calculator-app/node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js"],"sourcesContent":["import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\nimport { createUtil } from './simplify/util.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  var {\n    hasProperty,\n    isCommutative\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     simplify, resolve, derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   * @param {Object} options\n   *     Simplification options, as per simplify()\n   * @return {Node} Returns expression with basic simplifications applied\n   */\n\n  function simplifyCore(node, options) {\n    var context = options ? options.context : undefined;\n\n    if (hasProperty(node, 'trivial', context)) {\n      // This node does nothing if it has only one argument, so if so,\n      // return that argument simplified\n      if (isFunctionNode(node) && node.args.length === 1) {\n        return simplifyCore(node.args[0], options);\n      } // For other node types, we try the generic methods\n\n\n      var simpChild = false;\n      var childCount = 0;\n      node.forEach(c => {\n        ++childCount;\n\n        if (childCount === 1) {\n          simpChild = simplifyCore(c, options);\n        }\n      });\n\n      if (childCount === 1) {\n        return simpChild;\n      }\n    }\n\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0], options);\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0], options);\n\n      var a1 = simplifyCore(node.args[1], options);\n\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]), options);\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op && isCommutative(node, context)) {\n            var a00 = _a.args[0];\n\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          if (isCommutative(node, context)) {\n            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n          } else {\n            return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n      }\n\n      return new OperatorNode(node.op, node.fn, [_a, a1]);\n    } else if (isFunctionNode(node)) {\n      return new FunctionNode(simplifyCore(node.fn), node.args.map(n => simplifyCore(n, options)));\n    } else if (isArrayNode(node)) {\n      return new ArrayNode(node.items.map(n => simplifyCore(n, options)));\n    } else if (isAccessorNode(node)) {\n      return new AccessorNode(simplifyCore(node.object, options), simplifyCore(node.index, options));\n    } else if (isIndexNode(node)) {\n      return new IndexNode(node.dimensions.map(n => simplifyCore(n, options)));\n    } else if (isObjectNode(node)) {\n      var newProps = {};\n\n      for (var prop in node.properties) {\n        newProps[prop] = simplifyCore(node.properties[prop], options);\n      }\n\n      return new ObjectNode(newProps);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}