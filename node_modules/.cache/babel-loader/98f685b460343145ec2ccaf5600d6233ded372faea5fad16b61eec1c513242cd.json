{"ast":null,"code":"// TODO this could be improved by simplifying seperated constants under associative and commutative operators\nimport { isFraction, isMatrix, isNode, isArrayNode, isConstantNode, isIndexNode, isObjectNode, isOperatorNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nimport { createUtil } from './util.js';\nimport { noBignumber, noFraction } from '../../../utils/noop.js';\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'config', 'mathWithTransform', 'matrix', '?fraction', '?bignumber', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode'];\nexport var createSimplifyConstant = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    mathWithTransform,\n    matrix,\n    fraction,\n    bignumber,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    SymbolNode\n  } = _ref;\n  var {\n    isCommutative,\n    isAssociative,\n    allChildren,\n    createMakeNodeFunction\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n  function simplifyConstant(expr, options) {\n    return _ensureNode(foldFraction(expr, options));\n  }\n  function _removeFractions(thing) {\n    if (isFraction(thing)) {\n      return thing.valueOf();\n    }\n    if (thing instanceof Array) {\n      return thing.map(_removeFractions);\n    }\n    if (isMatrix(thing)) {\n      return matrix(_removeFractions(thing.valueOf()));\n    }\n    return thing;\n  }\n  function _eval(fnname, args, options) {\n    try {\n      return mathWithTransform[fnname].apply(null, args);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(_removeFractions);\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    },\n    string: function string(s) {\n      return new ConstantNode(s);\n    },\n    Matrix: function Matrix(m) {\n      return new ArrayNode(m.valueOf().map(e => _toNode(e)));\n    }\n  });\n  function _ensureNode(thing) {\n    if (isNode(thing)) {\n      return thing;\n    }\n    return _toNode(thing);\n  } // convert a number to a fraction only if it can be expressed exactly,\n  // and when both numerator and denominator are small enough\n\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\n\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\n        return f;\n      }\n    }\n    return n;\n  } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        if (bignumber === undefined) {\n          noBignumber();\n        }\n        return bignumber(s);\n      } else if (config.number === 'Fraction') {\n        if (fraction === undefined) {\n          noFraction();\n        }\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n      return _exactFraction(s.re, options);\n    },\n    'Matrix, Object': function MatrixObject(s, options) {\n      return matrix(_exactFraction(s.valueOf()));\n    },\n    'Array, Object': function ArrayObject(s, options) {\n      return s.map(_exactFraction);\n    }\n  });\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n    if (f.d === 1) {\n      return n;\n    }\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n  /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */\n\n  function _foldAccessor(obj, index, options) {\n    if (!isIndexNode(index)) {\n      // don't know what to do with that...\n      return new AccessorNode(_ensureNode(obj), _ensureNode(index));\n    }\n    if (isArrayNode(obj) || isMatrix(obj)) {\n      var remainingDims = Array.from(index.dimensions);\n      /* We will resolve constant indices one at a time, looking\n       * just in the first or second dimensions because (a) arrays\n       * of more than two dimensions are likely rare, and (b) pulling\n       * out the third or higher dimension would be pretty intricate.\n       * The price is that we miss simplifying [..3d array][x,y,1]\n       */\n\n      while (remainingDims.length > 0) {\n        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== 'string') {\n          var first = _toNumber(remainingDims.shift().value, options);\n          if (isArrayNode(obj)) {\n            obj = obj.items[first - 1];\n          } else {\n            // matrix\n            obj = obj.valueOf()[first - 1];\n            if (obj instanceof Array) {\n              obj = matrix(obj);\n            }\n          }\n        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== 'string') {\n          var second = _toNumber(remainingDims[1].value, options);\n          var tryItems = [];\n          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();\n          for (var item of fromItems) {\n            if (isArrayNode(item)) {\n              tryItems.push(item.items[second - 1]);\n            } else if (isMatrix(obj)) {\n              tryItems.push(item[second - 1]);\n            } else {\n              break;\n            }\n          }\n          if (tryItems.length === fromItems.length) {\n            if (isArrayNode(obj)) {\n              obj = new ArrayNode(tryItems);\n            } else {\n              // matrix\n              obj = matrix(tryItems);\n            }\n            remainingDims.splice(1, 1);\n          } else {\n            // extracting slice along 2nd dimension failed, give up\n            break;\n          }\n        } else {\n          // neither 1st or 2nd dimension is constant, give up\n          break;\n        }\n      }\n      if (remainingDims.length === index.dimensions.length) {\n        /* No successful constant indexing */\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      if (remainingDims.length > 0) {\n        /* Indexed some but not all dimensions */\n        index = new IndexNode(remainingDims);\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      /* All dimensions were constant, access completely resolved */\n\n      return obj;\n    }\n    if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {\n      var key = index.dimensions[0].value;\n      if (key in obj.properties) {\n        return obj.properties[key];\n      }\n      return new ConstantNode(); // undefined\n    }\n    /* Don't know how to index this sort of obj, at least not with this index */\n\n    return new AccessorNode(_ensureNode(obj), index);\n  }\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n\n  function foldOp(fn, args, makeNode, options) {\n    return args.reduce(function (a, b) {\n      if (!isNode(a) && !isNode(b)) {\n        try {\n          return _eval(fn, [a, b], options);\n        } catch (ignoreandcontinue) {}\n        a = _toNode(a);\n        b = _toNode(b);\n      } else if (!isNode(a)) {\n        a = _toNode(a);\n      } else if (!isNode(b)) {\n        b = _toNode(b);\n      }\n      return makeNode([a, b]);\n    });\n  } // destroys the original node and returns a folded one\n\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n      case 'ConstantNode':\n        switch (typeof node.value) {\n          case 'number':\n            return _toNumber(node.value, options);\n          case 'string':\n            return node.value;\n          default:\n            if (!isNaN(node.value)) return _toNumber(node.value, options);\n        }\n        return node;\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n          if (operatorFunctions.indexOf(node.name) === -1) {\n            var args = node.args.map(arg => foldFraction(arg, options)); // If all args are numbers\n\n            if (!args.some(isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontinue) {}\n            } // Size of a matrix does not depend on entries\n\n            if (node.name === 'size' && args.length === 1 && isArrayNode(args[0])) {\n              var sz = [];\n              var section = args[0];\n              while (isArrayNode(section)) {\n                sz.push(section.items.length);\n                section = section.items[0];\n              }\n              return matrix(sz);\n            } // Convert all args to nodes and construct a symbolic function call\n\n            return new FunctionNode(node.name, args.map(_ensureNode));\n          } else {// treat as operator\n          }\n        }\n\n      /* falls through */\n\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n          var _args;\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n          if (isOperatorNode(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n            if (!isNode(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node, options.context)) {\n            _args = allChildren(node, options.context);\n            _args = _args.map(arg => foldFraction(arg, options));\n            if (isCommutative(fn, options.context)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n              for (var i = 0; i < _args.length; i++) {\n                if (!isNode(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(arg => foldFraction(arg, options));\n            res = foldOp(fn, _args, makeNode, options);\n          }\n          return res;\n        }\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n      case 'AccessorNode':\n        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);\n      case 'ArrayNode':\n        {\n          var foldItems = node.items.map(item => foldFraction(item, options));\n          if (foldItems.some(isNode)) {\n            return new ArrayNode(foldItems.map(_ensureNode));\n          }\n          /* All literals -- return a Matrix so we can operate on it */\n\n          return matrix(foldItems);\n        }\n      case 'IndexNode':\n        {\n          return new IndexNode(node.dimensions.map(n => simplifyConstant(n, options)));\n        }\n      case 'ObjectNode':\n        {\n          var foldProps = {};\n          for (var prop in node.properties) {\n            foldProps[prop] = simplifyConstant(node.properties[prop], options);\n          }\n          return new ObjectNode(foldProps);\n        }\n      case 'AssignmentNode':\n      /* falls through */\n\n      case 'BlockNode':\n      /* falls through */\n\n      case 'FunctionAssignmentNode':\n      /* falls through */\n\n      case 'RangeNode':\n      /* falls through */\n\n      case 'ConditionalNode':\n      /* falls through */\n\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n  return simplifyConstant;\n});","map":{"version":3,"names":["isFraction","isMatrix","isNode","isArrayNode","isConstantNode","isIndexNode","isObjectNode","isOperatorNode","factory","createUtil","noBignumber","noFraction","name","dependencies","createSimplifyConstant","_ref","typed","config","mathWithTransform","matrix","fraction","bignumber","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","SymbolNode","isCommutative","isAssociative","allChildren","createMakeNodeFunction","simplifyConstant","expr","options","_ensureNode","foldFraction","_removeFractions","thing","valueOf","Array","map","_eval","fnname","args","apply","ignore","_toNumber","_toNode","Fraction","_fractionToNode","number","n","unaryMinusNode","BigNumber","Complex","s","Error","string","Matrix","m","e","_exactFraction","exactFractions","isFinite","f","fractionsLimit","Infinity","d","stringObject","undefined","parseFloat","FractionObject","BigNumberObject","numberObject","ComplexObject","im","re","MatrixObject","ArrayObject","vn","_foldAccessor","obj","index","remainingDims","from","dimensions","length","value","first","shift","items","second","tryItems","fromItems","item","push","splice","key","properties","foldOp","fn","makeNode","reduce","a","b","ignoreandcontinue","node","type","isNaN","rawArgs","operatorFunctions","indexOf","arg","some","sz","section","toString","_args","res","isUnary","context","consts","vars","i","unshift","content","object","foldItems","foldProps","prop","concat"],"sources":["/Users/front-end-projects/websites/calculator-app/node_modules/mathjs/lib/esm/function/algebra/simplify/simplifyConstant.js"],"sourcesContent":["// TODO this could be improved by simplifying seperated constants under associative and commutative operators\nimport { isFraction, isMatrix, isNode, isArrayNode, isConstantNode, isIndexNode, isObjectNode, isOperatorNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nimport { createUtil } from './util.js';\nimport { noBignumber, noFraction } from '../../../utils/noop.js';\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'config', 'mathWithTransform', 'matrix', '?fraction', '?bignumber', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode'];\nexport var createSimplifyConstant = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    mathWithTransform,\n    matrix,\n    fraction,\n    bignumber,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    SymbolNode\n  } = _ref;\n  var {\n    isCommutative,\n    isAssociative,\n    allChildren,\n    createMakeNodeFunction\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n\n  function simplifyConstant(expr, options) {\n    return _ensureNode(foldFraction(expr, options));\n  }\n\n  function _removeFractions(thing) {\n    if (isFraction(thing)) {\n      return thing.valueOf();\n    }\n\n    if (thing instanceof Array) {\n      return thing.map(_removeFractions);\n    }\n\n    if (isMatrix(thing)) {\n      return matrix(_removeFractions(thing.valueOf()));\n    }\n\n    return thing;\n  }\n\n  function _eval(fnname, args, options) {\n    try {\n      return mathWithTransform[fnname].apply(null, args);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(_removeFractions);\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    },\n    string: function string(s) {\n      return new ConstantNode(s);\n    },\n    Matrix: function Matrix(m) {\n      return new ArrayNode(m.valueOf().map(e => _toNode(e)));\n    }\n  });\n\n  function _ensureNode(thing) {\n    if (isNode(thing)) {\n      return thing;\n    }\n\n    return _toNode(thing);\n  } // convert a number to a fraction only if it can be expressed exactly,\n  // and when both numerator and denominator are small enough\n\n\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\n\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\n        return f;\n      }\n    }\n\n    return n;\n  } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n\n\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        if (bignumber === undefined) {\n          noBignumber();\n        }\n\n        return bignumber(s);\n      } else if (config.number === 'Fraction') {\n        if (fraction === undefined) {\n          noFraction();\n        }\n\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n\n      return _exactFraction(s.re, options);\n    },\n    'Matrix, Object': function MatrixObject(s, options) {\n      return matrix(_exactFraction(s.valueOf()));\n    },\n    'Array, Object': function ArrayObject(s, options) {\n      return s.map(_exactFraction);\n    }\n  });\n\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n\n    if (f.d === 1) {\n      return n;\n    }\n\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n  /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */\n\n\n  function _foldAccessor(obj, index, options) {\n    if (!isIndexNode(index)) {\n      // don't know what to do with that...\n      return new AccessorNode(_ensureNode(obj), _ensureNode(index));\n    }\n\n    if (isArrayNode(obj) || isMatrix(obj)) {\n      var remainingDims = Array.from(index.dimensions);\n      /* We will resolve constant indices one at a time, looking\n       * just in the first or second dimensions because (a) arrays\n       * of more than two dimensions are likely rare, and (b) pulling\n       * out the third or higher dimension would be pretty intricate.\n       * The price is that we miss simplifying [..3d array][x,y,1]\n       */\n\n      while (remainingDims.length > 0) {\n        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== 'string') {\n          var first = _toNumber(remainingDims.shift().value, options);\n\n          if (isArrayNode(obj)) {\n            obj = obj.items[first - 1];\n          } else {\n            // matrix\n            obj = obj.valueOf()[first - 1];\n\n            if (obj instanceof Array) {\n              obj = matrix(obj);\n            }\n          }\n        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== 'string') {\n          var second = _toNumber(remainingDims[1].value, options);\n\n          var tryItems = [];\n          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();\n\n          for (var item of fromItems) {\n            if (isArrayNode(item)) {\n              tryItems.push(item.items[second - 1]);\n            } else if (isMatrix(obj)) {\n              tryItems.push(item[second - 1]);\n            } else {\n              break;\n            }\n          }\n\n          if (tryItems.length === fromItems.length) {\n            if (isArrayNode(obj)) {\n              obj = new ArrayNode(tryItems);\n            } else {\n              // matrix\n              obj = matrix(tryItems);\n            }\n\n            remainingDims.splice(1, 1);\n          } else {\n            // extracting slice along 2nd dimension failed, give up\n            break;\n          }\n        } else {\n          // neither 1st or 2nd dimension is constant, give up\n          break;\n        }\n      }\n\n      if (remainingDims.length === index.dimensions.length) {\n        /* No successful constant indexing */\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n\n      if (remainingDims.length > 0) {\n        /* Indexed some but not all dimensions */\n        index = new IndexNode(remainingDims);\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      /* All dimensions were constant, access completely resolved */\n\n\n      return obj;\n    }\n\n    if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {\n      var key = index.dimensions[0].value;\n\n      if (key in obj.properties) {\n        return obj.properties[key];\n      }\n\n      return new ConstantNode(); // undefined\n    }\n    /* Don't know how to index this sort of obj, at least not with this index */\n\n\n    return new AccessorNode(_ensureNode(obj), index);\n  }\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n\n\n  function foldOp(fn, args, makeNode, options) {\n    return args.reduce(function (a, b) {\n      if (!isNode(a) && !isNode(b)) {\n        try {\n          return _eval(fn, [a, b], options);\n        } catch (ignoreandcontinue) {}\n\n        a = _toNode(a);\n        b = _toNode(b);\n      } else if (!isNode(a)) {\n        a = _toNode(a);\n      } else if (!isNode(b)) {\n        b = _toNode(b);\n      }\n\n      return makeNode([a, b]);\n    });\n  } // destroys the original node and returns a folded one\n\n\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n\n      case 'ConstantNode':\n        switch (typeof node.value) {\n          case 'number':\n            return _toNumber(node.value, options);\n\n          case 'string':\n            return node.value;\n\n          default:\n            if (!isNaN(node.value)) return _toNumber(node.value, options);\n        }\n\n        return node;\n\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n\n          if (operatorFunctions.indexOf(node.name) === -1) {\n            var args = node.args.map(arg => foldFraction(arg, options)); // If all args are numbers\n\n            if (!args.some(isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontinue) {}\n            } // Size of a matrix does not depend on entries\n\n\n            if (node.name === 'size' && args.length === 1 && isArrayNode(args[0])) {\n              var sz = [];\n              var section = args[0];\n\n              while (isArrayNode(section)) {\n                sz.push(section.items.length);\n                section = section.items[0];\n              }\n\n              return matrix(sz);\n            } // Convert all args to nodes and construct a symbolic function call\n\n\n            return new FunctionNode(node.name, args.map(_ensureNode));\n          } else {// treat as operator\n          }\n        }\n\n      /* falls through */\n\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n\n          var _args;\n\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n\n          if (isOperatorNode(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n\n            if (!isNode(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node, options.context)) {\n            _args = allChildren(node, options.context);\n            _args = _args.map(arg => foldFraction(arg, options));\n\n            if (isCommutative(fn, options.context)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n\n              for (var i = 0; i < _args.length; i++) {\n                if (!isNode(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(arg => foldFraction(arg, options));\n            res = foldOp(fn, _args, makeNode, options);\n          }\n\n          return res;\n        }\n\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n\n      case 'AccessorNode':\n        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);\n\n      case 'ArrayNode':\n        {\n          var foldItems = node.items.map(item => foldFraction(item, options));\n\n          if (foldItems.some(isNode)) {\n            return new ArrayNode(foldItems.map(_ensureNode));\n          }\n          /* All literals -- return a Matrix so we can operate on it */\n\n\n          return matrix(foldItems);\n        }\n\n      case 'IndexNode':\n        {\n          return new IndexNode(node.dimensions.map(n => simplifyConstant(n, options)));\n        }\n\n      case 'ObjectNode':\n        {\n          var foldProps = {};\n\n          for (var prop in node.properties) {\n            foldProps[prop] = simplifyConstant(node.properties[prop], options);\n          }\n\n          return new ObjectNode(foldProps);\n        }\n\n      case 'AssignmentNode':\n      /* falls through */\n\n      case 'BlockNode':\n      /* falls through */\n\n      case 'FunctionAssignmentNode':\n      /* falls through */\n\n      case 'RangeNode':\n      /* falls through */\n\n      case 'ConditionalNode':\n      /* falls through */\n\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n\n  return simplifyConstant;\n});"],"mappings":"AAAA;AACA,SAASA,UAAU,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,WAAW,EAAEC,cAAc,EAAEC,WAAW,EAAEC,YAAY,EAAEC,cAAc,QAAQ,sBAAsB;AAC3I,SAASC,OAAO,QAAQ,2BAA2B;AACnD,SAASC,UAAU,QAAQ,WAAW;AACtC,SAASC,WAAW,EAAEC,UAAU,QAAQ,wBAAwB;AAChE,IAAIC,IAAI,GAAG,kBAAkB;AAC7B,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,mBAAmB,EAAE,QAAQ,EAAE,WAAW,EAAE,YAAY,EAAE,cAAc,EAAE,WAAW,EAAE,cAAc,EAAE,cAAc,EAAE,WAAW,EAAE,YAAY,EAAE,cAAc,EAAE,YAAY,CAAC;AACtN,OAAO,IAAIC,sBAAsB,GAAG,eAAeN,OAAO,CAACI,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EACrF,IAAI;IACFC,KAAK;IACLC,MAAM;IACNC,iBAAiB;IACjBC,MAAM;IACNC,QAAQ;IACRC,SAAS;IACTC,YAAY;IACZC,SAAS;IACTC,YAAY;IACZC,YAAY;IACZC,SAAS;IACTC,UAAU;IACVC,YAAY;IACZC;EACF,CAAC,GAAGd,IAAI;EACR,IAAI;IACFe,aAAa;IACbC,aAAa;IACbC,WAAW;IACXC;EACF,CAAC,GAAGxB,UAAU,CAAC;IACbgB,YAAY;IACZG,YAAY;IACZC;EACF,CAAC,CAAC;EAEF,SAASK,gBAAgB,CAACC,IAAI,EAAEC,OAAO,EAAE;IACvC,OAAOC,WAAW,CAACC,YAAY,CAACH,IAAI,EAAEC,OAAO,CAAC,CAAC;EACjD;EAEA,SAASG,gBAAgB,CAACC,KAAK,EAAE;IAC/B,IAAIxC,UAAU,CAACwC,KAAK,CAAC,EAAE;MACrB,OAAOA,KAAK,CAACC,OAAO,EAAE;IACxB;IAEA,IAAID,KAAK,YAAYE,KAAK,EAAE;MAC1B,OAAOF,KAAK,CAACG,GAAG,CAACJ,gBAAgB,CAAC;IACpC;IAEA,IAAItC,QAAQ,CAACuC,KAAK,CAAC,EAAE;MACnB,OAAOrB,MAAM,CAACoB,gBAAgB,CAACC,KAAK,CAACC,OAAO,EAAE,CAAC,CAAC;IAClD;IAEA,OAAOD,KAAK;EACd;EAEA,SAASI,KAAK,CAACC,MAAM,EAAEC,IAAI,EAAEV,OAAO,EAAE;IACpC,IAAI;MACF,OAAOlB,iBAAiB,CAAC2B,MAAM,CAAC,CAACE,KAAK,CAAC,IAAI,EAAED,IAAI,CAAC;IACpD,CAAC,CAAC,OAAOE,MAAM,EAAE;MACf;MACAF,IAAI,GAAGA,IAAI,CAACH,GAAG,CAACJ,gBAAgB,CAAC;MACjC,OAAOU,SAAS,CAAC/B,iBAAiB,CAAC2B,MAAM,CAAC,CAACE,KAAK,CAAC,IAAI,EAAED,IAAI,CAAC,EAAEV,OAAO,CAAC;IACxE;EACF;EAEA,IAAIc,OAAO,GAAGlC,KAAK,CAAC;IAClBmC,QAAQ,EAAEC,eAAe;IACzBC,MAAM,EAAE,SAASA,MAAM,CAACC,CAAC,EAAE;MACzB,IAAIA,CAAC,GAAG,CAAC,EAAE;QACT,OAAOC,cAAc,CAAC,IAAI/B,YAAY,CAAC,CAAC8B,CAAC,CAAC,CAAC;MAC7C;MAEA,OAAO,IAAI9B,YAAY,CAAC8B,CAAC,CAAC;IAC5B,CAAC;IACDE,SAAS,EAAE,SAASA,SAAS,CAACF,CAAC,EAAE;MAC/B,IAAIA,CAAC,GAAG,CAAC,EAAE;QACT,OAAOC,cAAc,CAAC,IAAI/B,YAAY,CAAC,CAAC8B,CAAC,CAAC,CAAC;MAC7C;MAEA,OAAO,IAAI9B,YAAY,CAAC8B,CAAC,CAAC,CAAC,CAAC;IAC9B,CAAC;;IACDG,OAAO,EAAE,SAASA,OAAO,CAACC,CAAC,EAAE;MAC3B,MAAM,IAAIC,KAAK,CAAC,uCAAuC,CAAC;IAC1D,CAAC;IACDC,MAAM,EAAE,SAASA,MAAM,CAACF,CAAC,EAAE;MACzB,OAAO,IAAIlC,YAAY,CAACkC,CAAC,CAAC;IAC5B,CAAC;IACDG,MAAM,EAAE,SAASA,MAAM,CAACC,CAAC,EAAE;MACzB,OAAO,IAAIvC,SAAS,CAACuC,CAAC,CAACrB,OAAO,EAAE,CAACE,GAAG,CAACoB,CAAC,IAAIb,OAAO,CAACa,CAAC,CAAC,CAAC,CAAC;IACxD;EACF,CAAC,CAAC;EAEF,SAAS1B,WAAW,CAACG,KAAK,EAAE;IAC1B,IAAItC,MAAM,CAACsC,KAAK,CAAC,EAAE;MACjB,OAAOA,KAAK;IACd;IAEA,OAAOU,OAAO,CAACV,KAAK,CAAC;EACvB,CAAC,CAAC;EACF;;EAGA,SAASwB,cAAc,CAACV,CAAC,EAAElB,OAAO,EAAE;IAClC,IAAI6B,cAAc,GAAG7B,OAAO,IAAIA,OAAO,CAAC6B,cAAc,KAAK,KAAK;IAEhE,IAAIA,cAAc,IAAIC,QAAQ,CAACZ,CAAC,CAAC,IAAIlC,QAAQ,EAAE;MAC7C,IAAI+C,CAAC,GAAG/C,QAAQ,CAACkC,CAAC,CAAC;MACnB,IAAIc,cAAc,GAAGhC,OAAO,IAAI,OAAOA,OAAO,CAACgC,cAAc,KAAK,QAAQ,GAAGhC,OAAO,CAACgC,cAAc,GAAGC,QAAQ,CAAC,CAAC;;MAEhH,IAAIF,CAAC,CAAC1B,OAAO,EAAE,KAAKa,CAAC,IAAIa,CAAC,CAACb,CAAC,GAAGc,cAAc,IAAID,CAAC,CAACG,CAAC,GAAGF,cAAc,EAAE;QACrE,OAAOD,CAAC;MACV;IACF;IAEA,OAAOb,CAAC;EACV,CAAC,CAAC;EACF;;EAGA,IAAIL,SAAS,GAAGjC,KAAK,CAAC;IACpB,gBAAgB,EAAE,SAASuD,YAAY,CAACb,CAAC,EAAEtB,OAAO,EAAE;MAClD,IAAInB,MAAM,CAACoC,MAAM,KAAK,WAAW,EAAE;QACjC,IAAIhC,SAAS,KAAKmD,SAAS,EAAE;UAC3B9D,WAAW,EAAE;QACf;QAEA,OAAOW,SAAS,CAACqC,CAAC,CAAC;MACrB,CAAC,MAAM,IAAIzC,MAAM,CAACoC,MAAM,KAAK,UAAU,EAAE;QACvC,IAAIjC,QAAQ,KAAKoD,SAAS,EAAE;UAC1B7D,UAAU,EAAE;QACd;QAEA,OAAOS,QAAQ,CAACsC,CAAC,CAAC;MACpB,CAAC,MAAM;QACL,IAAIJ,CAAC,GAAGmB,UAAU,CAACf,CAAC,CAAC;QACrB,OAAOM,cAAc,CAACV,CAAC,EAAElB,OAAO,CAAC;MACnC;IACF,CAAC;IACD,kBAAkB,EAAE,SAASsC,cAAc,CAAChB,CAAC,EAAEtB,OAAO,EAAE;MACtD,OAAOsB,CAAC;IACV,CAAC;IACD;IACA,mBAAmB,EAAE,SAASiB,eAAe,CAACjB,CAAC,EAAEtB,OAAO,EAAE;MACxD,OAAOsB,CAAC;IACV,CAAC;IACD;IACA,gBAAgB,EAAE,SAASkB,YAAY,CAAClB,CAAC,EAAEtB,OAAO,EAAE;MAClD,OAAO4B,cAAc,CAACN,CAAC,EAAEtB,OAAO,CAAC;IACnC,CAAC;IACD,iBAAiB,EAAE,SAASyC,aAAa,CAACnB,CAAC,EAAEtB,OAAO,EAAE;MACpD,IAAIsB,CAAC,CAACoB,EAAE,KAAK,CAAC,EAAE;QACd,OAAOpB,CAAC;MACV;MAEA,OAAOM,cAAc,CAACN,CAAC,CAACqB,EAAE,EAAE3C,OAAO,CAAC;IACtC,CAAC;IACD,gBAAgB,EAAE,SAAS4C,YAAY,CAACtB,CAAC,EAAEtB,OAAO,EAAE;MAClD,OAAOjB,MAAM,CAAC6C,cAAc,CAACN,CAAC,CAACjB,OAAO,EAAE,CAAC,CAAC;IAC5C,CAAC;IACD,eAAe,EAAE,SAASwC,WAAW,CAACvB,CAAC,EAAEtB,OAAO,EAAE;MAChD,OAAOsB,CAAC,CAACf,GAAG,CAACqB,cAAc,CAAC;IAC9B;EACF,CAAC,CAAC;EAEF,SAAST,cAAc,CAACD,CAAC,EAAE;IACzB,OAAO,IAAI1B,YAAY,CAAC,GAAG,EAAE,YAAY,EAAE,CAAC0B,CAAC,CAAC,CAAC;EACjD;EAEA,SAASF,eAAe,CAACe,CAAC,EAAE;IAC1B,IAAIb,CAAC;IACL,IAAI4B,EAAE,GAAGf,CAAC,CAACT,CAAC,GAAGS,CAAC,CAACb,CAAC;IAElB,IAAI4B,EAAE,GAAG,CAAC,EAAE;MACV5B,CAAC,GAAG,IAAI1B,YAAY,CAAC,GAAG,EAAE,YAAY,EAAE,CAAC,IAAIJ,YAAY,CAAC,CAAC0D,EAAE,CAAC,CAAC,CAAC;IAClE,CAAC,MAAM;MACL5B,CAAC,GAAG,IAAI9B,YAAY,CAAC0D,EAAE,CAAC;IAC1B;IAEA,IAAIf,CAAC,CAACG,CAAC,KAAK,CAAC,EAAE;MACb,OAAOhB,CAAC;IACV;IAEA,OAAO,IAAI1B,YAAY,CAAC,GAAG,EAAE,QAAQ,EAAE,CAAC0B,CAAC,EAAE,IAAI9B,YAAY,CAAC2C,CAAC,CAACG,CAAC,CAAC,CAAC,CAAC;EACpE;EACA;;EAGA,SAASa,aAAa,CAACC,GAAG,EAAEC,KAAK,EAAEjD,OAAO,EAAE;IAC1C,IAAI,CAAC/B,WAAW,CAACgF,KAAK,CAAC,EAAE;MACvB;MACA,OAAO,IAAI/D,YAAY,CAACe,WAAW,CAAC+C,GAAG,CAAC,EAAE/C,WAAW,CAACgD,KAAK,CAAC,CAAC;IAC/D;IAEA,IAAIlF,WAAW,CAACiF,GAAG,CAAC,IAAInF,QAAQ,CAACmF,GAAG,CAAC,EAAE;MACrC,IAAIE,aAAa,GAAG5C,KAAK,CAAC6C,IAAI,CAACF,KAAK,CAACG,UAAU,CAAC;MAChD;AACN;AACA;AACA;AACA;AACA;;MAEM,OAAOF,aAAa,CAACG,MAAM,GAAG,CAAC,EAAE;QAC/B,IAAIrF,cAAc,CAACkF,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,OAAOA,aAAa,CAAC,CAAC,CAAC,CAACI,KAAK,KAAK,QAAQ,EAAE;UAClF,IAAIC,KAAK,GAAG1C,SAAS,CAACqC,aAAa,CAACM,KAAK,EAAE,CAACF,KAAK,EAAEtD,OAAO,CAAC;UAE3D,IAAIjC,WAAW,CAACiF,GAAG,CAAC,EAAE;YACpBA,GAAG,GAAGA,GAAG,CAACS,KAAK,CAACF,KAAK,GAAG,CAAC,CAAC;UAC5B,CAAC,MAAM;YACL;YACAP,GAAG,GAAGA,GAAG,CAAC3C,OAAO,EAAE,CAACkD,KAAK,GAAG,CAAC,CAAC;YAE9B,IAAIP,GAAG,YAAY1C,KAAK,EAAE;cACxB0C,GAAG,GAAGjE,MAAM,CAACiE,GAAG,CAAC;YACnB;UACF;QACF,CAAC,MAAM,IAAIE,aAAa,CAACG,MAAM,GAAG,CAAC,IAAIrF,cAAc,CAACkF,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,OAAOA,aAAa,CAAC,CAAC,CAAC,CAACI,KAAK,KAAK,QAAQ,EAAE;UACrH,IAAII,MAAM,GAAG7C,SAAS,CAACqC,aAAa,CAAC,CAAC,CAAC,CAACI,KAAK,EAAEtD,OAAO,CAAC;UAEvD,IAAI2D,QAAQ,GAAG,EAAE;UACjB,IAAIC,SAAS,GAAG7F,WAAW,CAACiF,GAAG,CAAC,GAAGA,GAAG,CAACS,KAAK,GAAGT,GAAG,CAAC3C,OAAO,EAAE;UAE5D,KAAK,IAAIwD,IAAI,IAAID,SAAS,EAAE;YAC1B,IAAI7F,WAAW,CAAC8F,IAAI,CAAC,EAAE;cACrBF,QAAQ,CAACG,IAAI,CAACD,IAAI,CAACJ,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,CAAC;YACvC,CAAC,MAAM,IAAI7F,QAAQ,CAACmF,GAAG,CAAC,EAAE;cACxBW,QAAQ,CAACG,IAAI,CAACD,IAAI,CAACH,MAAM,GAAG,CAAC,CAAC,CAAC;YACjC,CAAC,MAAM;cACL;YACF;UACF;UAEA,IAAIC,QAAQ,CAACN,MAAM,KAAKO,SAAS,CAACP,MAAM,EAAE;YACxC,IAAItF,WAAW,CAACiF,GAAG,CAAC,EAAE;cACpBA,GAAG,GAAG,IAAI7D,SAAS,CAACwE,QAAQ,CAAC;YAC/B,CAAC,MAAM;cACL;cACAX,GAAG,GAAGjE,MAAM,CAAC4E,QAAQ,CAAC;YACxB;YAEAT,aAAa,CAACa,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;UAC5B,CAAC,MAAM;YACL;YACA;UACF;QACF,CAAC,MAAM;UACL;UACA;QACF;MACF;MAEA,IAAIb,aAAa,CAACG,MAAM,KAAKJ,KAAK,CAACG,UAAU,CAACC,MAAM,EAAE;QACpD;QACA,OAAO,IAAInE,YAAY,CAACe,WAAW,CAAC+C,GAAG,CAAC,EAAEC,KAAK,CAAC;MAClD;MAEA,IAAIC,aAAa,CAACG,MAAM,GAAG,CAAC,EAAE;QAC5B;QACAJ,KAAK,GAAG,IAAI3D,SAAS,CAAC4D,aAAa,CAAC;QACpC,OAAO,IAAIhE,YAAY,CAACe,WAAW,CAAC+C,GAAG,CAAC,EAAEC,KAAK,CAAC;MAClD;MACA;;MAGA,OAAOD,GAAG;IACZ;IAEA,IAAI9E,YAAY,CAAC8E,GAAG,CAAC,IAAIC,KAAK,CAACG,UAAU,CAACC,MAAM,KAAK,CAAC,IAAIrF,cAAc,CAACiF,KAAK,CAACG,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;MAC7F,IAAIY,GAAG,GAAGf,KAAK,CAACG,UAAU,CAAC,CAAC,CAAC,CAACE,KAAK;MAEnC,IAAIU,GAAG,IAAIhB,GAAG,CAACiB,UAAU,EAAE;QACzB,OAAOjB,GAAG,CAACiB,UAAU,CAACD,GAAG,CAAC;MAC5B;MAEA,OAAO,IAAI5E,YAAY,EAAE,CAAC,CAAC;IAC7B;IACA;;IAGA,OAAO,IAAIF,YAAY,CAACe,WAAW,CAAC+C,GAAG,CAAC,EAAEC,KAAK,CAAC;EAClD;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAGE,SAASiB,MAAM,CAACC,EAAE,EAAEzD,IAAI,EAAE0D,QAAQ,EAAEpE,OAAO,EAAE;IAC3C,OAAOU,IAAI,CAAC2D,MAAM,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;MACjC,IAAI,CAACzG,MAAM,CAACwG,CAAC,CAAC,IAAI,CAACxG,MAAM,CAACyG,CAAC,CAAC,EAAE;QAC5B,IAAI;UACF,OAAO/D,KAAK,CAAC2D,EAAE,EAAE,CAACG,CAAC,EAAEC,CAAC,CAAC,EAAEvE,OAAO,CAAC;QACnC,CAAC,CAAC,OAAOwE,iBAAiB,EAAE,CAAC;QAE7BF,CAAC,GAAGxD,OAAO,CAACwD,CAAC,CAAC;QACdC,CAAC,GAAGzD,OAAO,CAACyD,CAAC,CAAC;MAChB,CAAC,MAAM,IAAI,CAACzG,MAAM,CAACwG,CAAC,CAAC,EAAE;QACrBA,CAAC,GAAGxD,OAAO,CAACwD,CAAC,CAAC;MAChB,CAAC,MAAM,IAAI,CAACxG,MAAM,CAACyG,CAAC,CAAC,EAAE;QACrBA,CAAC,GAAGzD,OAAO,CAACyD,CAAC,CAAC;MAChB;MAEA,OAAOH,QAAQ,CAAC,CAACE,CAAC,EAAEC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC;EACJ,CAAC,CAAC;;EAGF,SAASrE,YAAY,CAACuE,IAAI,EAAEzE,OAAO,EAAE;IACnC,QAAQyE,IAAI,CAACC,IAAI;MACf,KAAK,YAAY;QACf,OAAOD,IAAI;MAEb,KAAK,cAAc;QACjB,QAAQ,OAAOA,IAAI,CAACnB,KAAK;UACvB,KAAK,QAAQ;YACX,OAAOzC,SAAS,CAAC4D,IAAI,CAACnB,KAAK,EAAEtD,OAAO,CAAC;UAEvC,KAAK,QAAQ;YACX,OAAOyE,IAAI,CAACnB,KAAK;UAEnB;YACE,IAAI,CAACqB,KAAK,CAACF,IAAI,CAACnB,KAAK,CAAC,EAAE,OAAOzC,SAAS,CAAC4D,IAAI,CAACnB,KAAK,EAAEtD,OAAO,CAAC;QAAC;QAGlE,OAAOyE,IAAI;MAEb,KAAK,cAAc;QACjB,IAAI3F,iBAAiB,CAAC2F,IAAI,CAACjG,IAAI,CAAC,IAAIM,iBAAiB,CAAC2F,IAAI,CAACjG,IAAI,CAAC,CAACoG,OAAO,EAAE;UACxE,OAAOH,IAAI;QACb;QAEA;UACE;UACA,IAAII,iBAAiB,GAAG,CAAC,KAAK,EAAE,UAAU,CAAC;UAE3C,IAAIA,iBAAiB,CAACC,OAAO,CAACL,IAAI,CAACjG,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;YAC/C,IAAIkC,IAAI,GAAG+D,IAAI,CAAC/D,IAAI,CAACH,GAAG,CAACwE,GAAG,IAAI7E,YAAY,CAAC6E,GAAG,EAAE/E,OAAO,CAAC,CAAC,CAAC,CAAC;;YAE7D,IAAI,CAACU,IAAI,CAACsE,IAAI,CAAClH,MAAM,CAAC,EAAE;cACtB,IAAI;gBACF,OAAO0C,KAAK,CAACiE,IAAI,CAACjG,IAAI,EAAEkC,IAAI,EAAEV,OAAO,CAAC;cACxC,CAAC,CAAC,OAAOwE,iBAAiB,EAAE,CAAC;YAC/B,CAAC,CAAC;;YAGF,IAAIC,IAAI,CAACjG,IAAI,KAAK,MAAM,IAAIkC,IAAI,CAAC2C,MAAM,KAAK,CAAC,IAAItF,WAAW,CAAC2C,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;cACrE,IAAIuE,EAAE,GAAG,EAAE;cACX,IAAIC,OAAO,GAAGxE,IAAI,CAAC,CAAC,CAAC;cAErB,OAAO3C,WAAW,CAACmH,OAAO,CAAC,EAAE;gBAC3BD,EAAE,CAACnB,IAAI,CAACoB,OAAO,CAACzB,KAAK,CAACJ,MAAM,CAAC;gBAC7B6B,OAAO,GAAGA,OAAO,CAACzB,KAAK,CAAC,CAAC,CAAC;cAC5B;cAEA,OAAO1E,MAAM,CAACkG,EAAE,CAAC;YACnB,CAAC,CAAC;;YAGF,OAAO,IAAI5F,YAAY,CAACoF,IAAI,CAACjG,IAAI,EAAEkC,IAAI,CAACH,GAAG,CAACN,WAAW,CAAC,CAAC;UAC3D,CAAC,MAAM,CAAC;UAAA;QAEV;;MAEF;;MAEA,KAAK,cAAc;QACjB;UACE,IAAIkE,EAAE,GAAGM,IAAI,CAACN,EAAE,CAACgB,QAAQ,EAAE;UAE3B,IAAIC,KAAK;UAET,IAAIC,GAAG;UACP,IAAIjB,QAAQ,GAAGvE,sBAAsB,CAAC4E,IAAI,CAAC;UAE3C,IAAItG,cAAc,CAACsG,IAAI,CAAC,IAAIA,IAAI,CAACa,OAAO,EAAE,EAAE;YAC1CF,KAAK,GAAG,CAAClF,YAAY,CAACuE,IAAI,CAAC/D,IAAI,CAAC,CAAC,CAAC,EAAEV,OAAO,CAAC,CAAC;YAE7C,IAAI,CAAClC,MAAM,CAACsH,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;cACrBC,GAAG,GAAG7E,KAAK,CAAC2D,EAAE,EAAEiB,KAAK,EAAEpF,OAAO,CAAC;YACjC,CAAC,MAAM;cACLqF,GAAG,GAAGjB,QAAQ,CAACgB,KAAK,CAAC;YACvB;UACF,CAAC,MAAM,IAAIzF,aAAa,CAAC8E,IAAI,EAAEzE,OAAO,CAACuF,OAAO,CAAC,EAAE;YAC/CH,KAAK,GAAGxF,WAAW,CAAC6E,IAAI,EAAEzE,OAAO,CAACuF,OAAO,CAAC;YAC1CH,KAAK,GAAGA,KAAK,CAAC7E,GAAG,CAACwE,GAAG,IAAI7E,YAAY,CAAC6E,GAAG,EAAE/E,OAAO,CAAC,CAAC;YAEpD,IAAIN,aAAa,CAACyE,EAAE,EAAEnE,OAAO,CAACuF,OAAO,CAAC,EAAE;cACtC;cACA,IAAIC,MAAM,GAAG,EAAE;cACf,IAAIC,IAAI,GAAG,EAAE;cAEb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,KAAK,CAAC/B,MAAM,EAAEqC,CAAC,EAAE,EAAE;gBACrC,IAAI,CAAC5H,MAAM,CAACsH,KAAK,CAACM,CAAC,CAAC,CAAC,EAAE;kBACrBF,MAAM,CAAC1B,IAAI,CAACsB,KAAK,CAACM,CAAC,CAAC,CAAC;gBACvB,CAAC,MAAM;kBACLD,IAAI,CAAC3B,IAAI,CAACsB,KAAK,CAACM,CAAC,CAAC,CAAC;gBACrB;cACF;cAEA,IAAIF,MAAM,CAACnC,MAAM,GAAG,CAAC,EAAE;gBACrBgC,GAAG,GAAGnB,MAAM,CAACC,EAAE,EAAEqB,MAAM,EAAEpB,QAAQ,EAAEpE,OAAO,CAAC;gBAC3CyF,IAAI,CAACE,OAAO,CAACN,GAAG,CAAC;gBACjBA,GAAG,GAAGnB,MAAM,CAACC,EAAE,EAAEsB,IAAI,EAAErB,QAAQ,EAAEpE,OAAO,CAAC;cAC3C,CAAC,MAAM;gBACL;gBACAqF,GAAG,GAAGnB,MAAM,CAACC,EAAE,EAAEiB,KAAK,EAAEhB,QAAQ,EAAEpE,OAAO,CAAC;cAC5C;YACF,CAAC,MAAM;cACL;cACAqF,GAAG,GAAGnB,MAAM,CAACC,EAAE,EAAEiB,KAAK,EAAEhB,QAAQ,EAAEpE,OAAO,CAAC;YAC5C;UACF,CAAC,MAAM;YACL;YACAoF,KAAK,GAAGX,IAAI,CAAC/D,IAAI,CAACH,GAAG,CAACwE,GAAG,IAAI7E,YAAY,CAAC6E,GAAG,EAAE/E,OAAO,CAAC,CAAC;YACxDqF,GAAG,GAAGnB,MAAM,CAACC,EAAE,EAAEiB,KAAK,EAAEhB,QAAQ,EAAEpE,OAAO,CAAC;UAC5C;UAEA,OAAOqF,GAAG;QACZ;MAEF,KAAK,iBAAiB;QACpB;QACA,OAAOnF,YAAY,CAACuE,IAAI,CAACmB,OAAO,EAAE5F,OAAO,CAAC;MAE5C,KAAK,cAAc;QACjB,OAAO+C,aAAa,CAAC7C,YAAY,CAACuE,IAAI,CAACoB,MAAM,EAAE7F,OAAO,CAAC,EAAEE,YAAY,CAACuE,IAAI,CAACxB,KAAK,EAAEjD,OAAO,CAAC,EAAEA,OAAO,CAAC;MAEtG,KAAK,WAAW;QACd;UACE,IAAI8F,SAAS,GAAGrB,IAAI,CAAChB,KAAK,CAAClD,GAAG,CAACsD,IAAI,IAAI3D,YAAY,CAAC2D,IAAI,EAAE7D,OAAO,CAAC,CAAC;UAEnE,IAAI8F,SAAS,CAACd,IAAI,CAAClH,MAAM,CAAC,EAAE;YAC1B,OAAO,IAAIqB,SAAS,CAAC2G,SAAS,CAACvF,GAAG,CAACN,WAAW,CAAC,CAAC;UAClD;UACA;;UAGA,OAAOlB,MAAM,CAAC+G,SAAS,CAAC;QAC1B;MAEF,KAAK,WAAW;QACd;UACE,OAAO,IAAIxG,SAAS,CAACmF,IAAI,CAACrB,UAAU,CAAC7C,GAAG,CAACW,CAAC,IAAIpB,gBAAgB,CAACoB,CAAC,EAAElB,OAAO,CAAC,CAAC,CAAC;QAC9E;MAEF,KAAK,YAAY;QACf;UACE,IAAI+F,SAAS,GAAG,CAAC,CAAC;UAElB,KAAK,IAAIC,IAAI,IAAIvB,IAAI,CAACR,UAAU,EAAE;YAChC8B,SAAS,CAACC,IAAI,CAAC,GAAGlG,gBAAgB,CAAC2E,IAAI,CAACR,UAAU,CAAC+B,IAAI,CAAC,EAAEhG,OAAO,CAAC;UACpE;UAEA,OAAO,IAAIT,UAAU,CAACwG,SAAS,CAAC;QAClC;MAEF,KAAK,gBAAgB;MACrB;;MAEA,KAAK,WAAW;MAChB;;MAEA,KAAK,wBAAwB;MAC7B;;MAEA,KAAK,WAAW;MAChB;;MAEA,KAAK,iBAAiB;MACtB;;MAEA;QACE,MAAM,IAAIxE,KAAK,CAAC,+CAA+C,CAAC0E,MAAM,CAACxB,IAAI,CAACC,IAAI,CAAC,CAAC;IAAC;EAEzF;EAEA,OAAO5E,gBAAgB;AACzB,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}