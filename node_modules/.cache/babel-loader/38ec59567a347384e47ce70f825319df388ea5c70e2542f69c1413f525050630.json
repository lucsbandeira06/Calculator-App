{"ast":null,"code":"import { map } from '../../utils/array.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { isArray, isConstantNode, isMatrix, isNode, isString, typeOf } from '../../utils/is.js';\nimport { escape } from '../../utils/string.js';\nvar name = 'IndexNode';\nvar dependencies = ['Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node,\n    size\n  } = _ref;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (dimension, i) {\n      var needsEnd = dimension.filter(node => node.isSymbolNode && node.name === 'end').length > 0;\n      if (needsEnd) {\n        // SymbolNode 'end' is used inside the index,\n        // like in `A[end]` or `A[end - 2]`\n        var childArgNames = Object.create(argNames);\n        childArgNames.end = true;\n        var _evalDimension = dimension._compile(math, childArgNames);\n        return function evalDimension(scope, args, context) {\n          if (!isMatrix(context) && !isArray(context) && !isString(context)) {\n            throw new TypeError('Cannot resolve \"end\": ' + 'context must be a Matrix, Array, or string but is ' + typeOf(context));\n          }\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return _evalDimension(scope, childArgs, context);\n        };\n      } else {\n        // SymbolNode `end` not used\n        return dimension._compile(math, argNames);\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index(...dimensions);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  };\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["map","getSafeProperty","factory","isArray","isConstantNode","isMatrix","isNode","isString","typeOf","escape","name","dependencies","createIndexNode","_ref","Node","size","IndexNode","dimensions","dotNotation","SyntaxError","Array","every","TypeError","isObjectProperty","Error","prototype","type","isIndexNode","_compile","math","argNames","evalDimensions","dimension","i","needsEnd","filter","node","isSymbolNode","length","childArgNames","Object","create","end","_evalDimension","evalDimension","scope","args","context","s","valueOf","childArgs","index","evalIndexNode","forEach","callback","_ifNode","clone","slice","value","getObjectProperty","_toString","options","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","range","toTex","isClass"],"sources":["/Users/front-end-projects/websites/calculator-app/node_modules/mathjs/lib/esm/expression/node/IndexNode.js"],"sourcesContent":["import { map } from '../../utils/array.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { isArray, isConstantNode, isMatrix, isNode, isString, typeOf } from '../../utils/is.js';\nimport { escape } from '../../utils/string.js';\nvar name = 'IndexNode';\nvar dependencies = ['Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node,\n    size\n  } = _ref;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (dimension, i) {\n      var needsEnd = dimension.filter(node => node.isSymbolNode && node.name === 'end').length > 0;\n\n      if (needsEnd) {\n        // SymbolNode 'end' is used inside the index,\n        // like in `A[end]` or `A[end - 2]`\n        var childArgNames = Object.create(argNames);\n        childArgNames.end = true;\n\n        var _evalDimension = dimension._compile(math, childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          if (!isMatrix(context) && !isArray(context) && !isString(context)) {\n            throw new TypeError('Cannot resolve \"end\": ' + 'context must be a Matrix, Array, or string but is ' + typeOf(context));\n          }\n\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return _evalDimension(scope, childArgs, context);\n        };\n      } else {\n        // SymbolNode `end` not used\n        return dimension._compile(math, argNames);\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index(...dimensions);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  };\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}