{"ast":null,"code":"/* eslint-disable no-loss-of-precision */\n// References\n// ----------\n// [1] Hare, \"Computing the Principal Branch of log-Gamma\", Journal of Algorithms, 1997.\n// [2] https://math.stackexchange.com/questions/1338753/how-do-i-calculate-values-for-gamma-function-with-complex-arguments\nimport { lgammaNumber, lnSqrt2PI } from '../../plain/number/index.js';\nimport { factory } from '../../utils/factory.js';\nimport { copysign } from '../../utils/number.js';\nvar name = 'lgamma';\nvar dependencies = ['Complex', 'typed'];\nexport var createLgamma = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Complex: _Complex,\n    typed\n  } = _ref;\n  // Stirling series is non-convergent, we need to use the recurrence `lgamma(z) = lgamma(z+1) - log z` to get\n  // sufficient accuracy.\n  //\n  // These two values are copied from Scipy implementation:\n  // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L37\n  var SMALL_RE = 7;\n  var SMALL_IM = 7;\n  /**\n   * The coefficients are B[2*n]/(2*n*(2*n - 1)) where B[2*n] is the (2*n)th Bernoulli number. See (1.1) in [1].\n   *\n   * If you cannot access the paper, can also get these values from the formula in [2].\n   *\n   *    1 /     12 = 0.00833333333333333333333333333333\n   *    1 /    360 = 0.00277777777777777777777777777778\n   * ...\n   * 3617 / 133400 = 0.02955065359477124183006535947712\n   */\n\n  var coeffs = [-2.955065359477124183e-2, 6.4102564102564102564e-3, -1.9175269175269175269e-3, 8.4175084175084175084e-4, -5.952380952380952381e-4, 7.9365079365079365079e-4, -2.7777777777777777778e-3, 8.3333333333333333333e-2];\n  /**\n   * Logarithm of the gamma function for real, positive numbers and complex numbers,\n   * using Lanczos approximation for numbers and Stirling series for complex numbers.\n   *\n   * Syntax:\n   *\n   *    math.lgamma(n)\n   *\n   * Examples:\n   *\n   *    math.lgamma(5)       // returns 3.178053830347945\n   *    math.lgamma(0)       // returns Infinity\n   *    math.lgamma(-0.5)    // returns NaN\n   *    math.lgamma(math.i)  // returns -0.6509231993018536 - 1.8724366472624294i\n   *\n   * See also:\n   *\n   *    gamma\n   *\n   * @param {number | Complex} n   A real or complex number\n   * @return {number | Complex}    The log gamma of `n`\n   */\n\n  return typed(name, {\n    number: lgammaNumber,\n    Complex: function Complex(n) {\n      var TWOPI = 6.2831853071795864769252842; // 2*pi\n\n      var LOGPI = 1.1447298858494001741434262; // log(pi)\n\n      var REFLECTION = 0.1;\n      if (n.isNaN()) {\n        return new _Complex(NaN, NaN);\n      } else if (n.im === 0) {\n        return new _Complex(lgammaNumber(n.re), 0);\n      } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {\n        return lgammaStirling(n);\n      } else if (n.re <= REFLECTION) {\n        // Reflection formula. see Proposition 3.1 in [1]\n        var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25); // TODO: `complex.js sin` doesn't have extremely high precision, so this value `a` may lose a little precision,\n        // causing the computation results to be less accurate than the lgamma of real numbers\n\n        var a = n.mul(Math.PI).sin().log();\n        var b = this(new _Complex(1 - n.re, -n.im));\n        return new _Complex(LOGPI, tmp).sub(a).sub(b);\n      } else if (n.im >= 0) {\n        return lgammaRecurrence(n);\n      } else {\n        return lgammaRecurrence(n.conjugate()).conjugate();\n      }\n    },\n    BigNumber: function BigNumber() {\n      throw new Error(\"mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber\");\n    }\n  });\n  function lgammaStirling(z) {\n    // formula ref in [2]\n    // computation ref:\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L101\n    // left part\n    // x (log(x) - 1) + 1/2 (log(2PI) - log(x))\n    // => (x - 0.5) * log(x) - x + log(2PI) / 2\n    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI); // right part\n\n    var rz = new _Complex(1, 0).div(z);\n    var rzz = rz.div(z);\n    var a = coeffs[0];\n    var b = coeffs[1];\n    var r = 2 * rzz.re;\n    var s = rzz.re * rzz.re + rzz.im * rzz.im;\n    for (var i = 2; i < 8; i++) {\n      var tmp = b;\n      b = -s * a + coeffs[i];\n      a = r * a + tmp;\n    }\n    var rightPart = rz.mul(rzz.mul(a).add(b)); // plus left and right\n\n    return leftPart.add(rightPart);\n  }\n  function lgammaRecurrence(z) {\n    // computation ref:\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L78\n    var signflips = 0;\n    var sb = 0;\n    var shiftprod = z;\n    z = z.add(1);\n    while (z.re <= SMALL_RE) {\n      shiftprod = shiftprod.mul(z);\n      var nsb = shiftprod.im < 0 ? 1 : 0;\n      if (nsb !== 0 && sb === 0) signflips++;\n      sb = nsb;\n      z = z.add(1);\n    }\n    return lgammaStirling(z).sub(shiftprod.log()).sub(new _Complex(0, signflips * 2 * Math.PI * 1));\n  }\n});","map":{"version":3,"names":["lgammaNumber","lnSqrt2PI","factory","copysign","name","dependencies","createLgamma","_ref","Complex","_Complex","typed","SMALL_RE","SMALL_IM","coeffs","number","n","TWOPI","LOGPI","REFLECTION","isNaN","NaN","im","re","Math","abs","lgammaStirling","tmp","floor","a","mul","PI","sin","log","b","sub","lgammaRecurrence","conjugate","BigNumber","Error","z","leftPart","add","rz","div","rzz","r","s","i","rightPart","signflips","sb","shiftprod","nsb"],"sources":["/Users/front-end-projects/websites/calculator-app/node_modules/mathjs/lib/esm/function/probability/lgamma.js"],"sourcesContent":["/* eslint-disable no-loss-of-precision */\n// References\n// ----------\n// [1] Hare, \"Computing the Principal Branch of log-Gamma\", Journal of Algorithms, 1997.\n// [2] https://math.stackexchange.com/questions/1338753/how-do-i-calculate-values-for-gamma-function-with-complex-arguments\nimport { lgammaNumber, lnSqrt2PI } from '../../plain/number/index.js';\nimport { factory } from '../../utils/factory.js';\nimport { copysign } from '../../utils/number.js';\nvar name = 'lgamma';\nvar dependencies = ['Complex', 'typed'];\nexport var createLgamma = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Complex: _Complex,\n    typed\n  } = _ref;\n  // Stirling series is non-convergent, we need to use the recurrence `lgamma(z) = lgamma(z+1) - log z` to get\n  // sufficient accuracy.\n  //\n  // These two values are copied from Scipy implementation:\n  // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L37\n  var SMALL_RE = 7;\n  var SMALL_IM = 7;\n  /**\n   * The coefficients are B[2*n]/(2*n*(2*n - 1)) where B[2*n] is the (2*n)th Bernoulli number. See (1.1) in [1].\n   *\n   * If you cannot access the paper, can also get these values from the formula in [2].\n   *\n   *    1 /     12 = 0.00833333333333333333333333333333\n   *    1 /    360 = 0.00277777777777777777777777777778\n   * ...\n   * 3617 / 133400 = 0.02955065359477124183006535947712\n   */\n\n  var coeffs = [-2.955065359477124183e-2, 6.4102564102564102564e-3, -1.9175269175269175269e-3, 8.4175084175084175084e-4, -5.952380952380952381e-4, 7.9365079365079365079e-4, -2.7777777777777777778e-3, 8.3333333333333333333e-2];\n  /**\n   * Logarithm of the gamma function for real, positive numbers and complex numbers,\n   * using Lanczos approximation for numbers and Stirling series for complex numbers.\n   *\n   * Syntax:\n   *\n   *    math.lgamma(n)\n   *\n   * Examples:\n   *\n   *    math.lgamma(5)       // returns 3.178053830347945\n   *    math.lgamma(0)       // returns Infinity\n   *    math.lgamma(-0.5)    // returns NaN\n   *    math.lgamma(math.i)  // returns -0.6509231993018536 - 1.8724366472624294i\n   *\n   * See also:\n   *\n   *    gamma\n   *\n   * @param {number | Complex} n   A real or complex number\n   * @return {number | Complex}    The log gamma of `n`\n   */\n\n  return typed(name, {\n    number: lgammaNumber,\n    Complex: function Complex(n) {\n      var TWOPI = 6.2831853071795864769252842; // 2*pi\n\n      var LOGPI = 1.1447298858494001741434262; // log(pi)\n\n      var REFLECTION = 0.1;\n\n      if (n.isNaN()) {\n        return new _Complex(NaN, NaN);\n      } else if (n.im === 0) {\n        return new _Complex(lgammaNumber(n.re), 0);\n      } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {\n        return lgammaStirling(n);\n      } else if (n.re <= REFLECTION) {\n        // Reflection formula. see Proposition 3.1 in [1]\n        var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25); // TODO: `complex.js sin` doesn't have extremely high precision, so this value `a` may lose a little precision,\n        // causing the computation results to be less accurate than the lgamma of real numbers\n\n        var a = n.mul(Math.PI).sin().log();\n        var b = this(new _Complex(1 - n.re, -n.im));\n        return new _Complex(LOGPI, tmp).sub(a).sub(b);\n      } else if (n.im >= 0) {\n        return lgammaRecurrence(n);\n      } else {\n        return lgammaRecurrence(n.conjugate()).conjugate();\n      }\n    },\n    BigNumber: function BigNumber() {\n      throw new Error(\"mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber\");\n    }\n  });\n\n  function lgammaStirling(z) {\n    // formula ref in [2]\n    // computation ref:\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L101\n    // left part\n    // x (log(x) - 1) + 1/2 (log(2PI) - log(x))\n    // => (x - 0.5) * log(x) - x + log(2PI) / 2\n    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI); // right part\n\n    var rz = new _Complex(1, 0).div(z);\n    var rzz = rz.div(z);\n    var a = coeffs[0];\n    var b = coeffs[1];\n    var r = 2 * rzz.re;\n    var s = rzz.re * rzz.re + rzz.im * rzz.im;\n\n    for (var i = 2; i < 8; i++) {\n      var tmp = b;\n      b = -s * a + coeffs[i];\n      a = r * a + tmp;\n    }\n\n    var rightPart = rz.mul(rzz.mul(a).add(b)); // plus left and right\n\n    return leftPart.add(rightPart);\n  }\n\n  function lgammaRecurrence(z) {\n    // computation ref:\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L78\n    var signflips = 0;\n    var sb = 0;\n    var shiftprod = z;\n    z = z.add(1);\n\n    while (z.re <= SMALL_RE) {\n      shiftprod = shiftprod.mul(z);\n      var nsb = shiftprod.im < 0 ? 1 : 0;\n      if (nsb !== 0 && sb === 0) signflips++;\n      sb = nsb;\n      z = z.add(1);\n    }\n\n    return lgammaStirling(z).sub(shiftprod.log()).sub(new _Complex(0, signflips * 2 * Math.PI * 1));\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}