{"ast":null,"code":"import { isConstantNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'symbolicEqual';\nvar dependencies = ['parse', 'simplify', 'typed', 'OperatorNode'];\nexport var createSymbolicEqual = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    parse,\n    simplify,\n    typed,\n    OperatorNode\n  } = _ref;\n\n  /**\n   * Attempts to determine if two expressions are symbolically equal, i.e.\n   * one is the result of valid algebraic manipulations on the other.\n   * Currently, this simply checks if the difference of the two expressions\n   * simplifies down to 0. So there are two important caveats:\n   * 1. whether two expressions are symbolically equal depends on the\n   *     manipulations allowed. Therefore, this function takes an optional\n   *     third argument, which are the options that control the behavior\n   *     as documented for the `simplify()` function.\n   * 2. it is in general intractable to find the minimal simplification of\n   *     an arbitrarily complicated expression. So while a `true` value\n   *     of `symbolicEqual` ensures that the two expressions can be manipulated\n   *     to match each other, a `false` value does not absolutely rule this out.\n   *\n   * Syntax:\n   *\n   *    symbolicEqual(expr1, expr2)\n   *    symbolicEqual(expr1, expr2, options)\n   *\n   * Examples:\n   *\n   *    symbolicEqual('x*y', 'y*x') // true\n   *    symbolicEqual('x*y', 'y*x', {context: {multiply: {commutative: false}}})\n   *        //false\n   *    symbolicEqual('x/y', '(y*x^(-1))^(-1)') // true\n   *    symbolicEqual('abs(x)','x') // false\n   *    symbolicEqual('abs(x)','x', simplify.positiveContext) // true\n   *\n   * See also:\n   *\n   *    simplify, evaluate\n   *\n   * @param {Node|string} expr1  The first expression to compare\n   * @param {Node|string} expr2  The second expression to compare\n   * @param {Object} [options] Optional option object, passed to simplify\n   * @returns {boolean}\n   *     Returns true if a valid manipulation making the expressions equal\n   *     is found.\n   */\n  return typed(name, {\n    'string, string': function stringString(s1, s2) {\n      return this(parse(s1), parse(s2), {});\n    },\n    'string, string, Object': function stringStringObject(s1, s2, options) {\n      return this(parse(s1), parse(s2), options);\n    },\n    'Node, string': function NodeString(e1, s2) {\n      return this(e1, parse(s2), {});\n    },\n    'Node, string, Object': function NodeStringObject(e1, s2, options) {\n      return this(e1, parse(s2), options);\n    },\n    'string, Node': function stringNode(s1, e2) {\n      return this(parse(s1), e2, {});\n    },\n    'string, Node, Object': function stringNodeObject(s1, e2, options) {\n      return this(parse(s1), e2, options);\n    },\n    'Node, Node': function NodeNode(e1, e2) {\n      return this(e1, e2, {});\n    },\n    'Node, Node, Object': function NodeNodeObject(e1, e2, options) {\n      var diff = new OperatorNode('-', 'subtract', [e1, e2]);\n      var simplified = simplify(diff, {}, options);\n      return isConstantNode(simplified) && !simplified.value;\n    }\n  });\n});","map":{"version":3,"names":["isConstantNode","factory","name","dependencies","createSymbolicEqual","_ref","parse","simplify","typed","OperatorNode","stringString","s1","s2","stringStringObject","options","NodeString","e1","NodeStringObject","stringNode","e2","stringNodeObject","NodeNode","NodeNodeObject","diff","simplified","value"],"sources":["/Users/front-end-projects/websites/calculator-app/node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js"],"sourcesContent":["import { isConstantNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'symbolicEqual';\nvar dependencies = ['parse', 'simplify', 'typed', 'OperatorNode'];\nexport var createSymbolicEqual = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    parse,\n    simplify,\n    typed,\n    OperatorNode\n  } = _ref;\n\n  /**\n   * Attempts to determine if two expressions are symbolically equal, i.e.\n   * one is the result of valid algebraic manipulations on the other.\n   * Currently, this simply checks if the difference of the two expressions\n   * simplifies down to 0. So there are two important caveats:\n   * 1. whether two expressions are symbolically equal depends on the\n   *     manipulations allowed. Therefore, this function takes an optional\n   *     third argument, which are the options that control the behavior\n   *     as documented for the `simplify()` function.\n   * 2. it is in general intractable to find the minimal simplification of\n   *     an arbitrarily complicated expression. So while a `true` value\n   *     of `symbolicEqual` ensures that the two expressions can be manipulated\n   *     to match each other, a `false` value does not absolutely rule this out.\n   *\n   * Syntax:\n   *\n   *    symbolicEqual(expr1, expr2)\n   *    symbolicEqual(expr1, expr2, options)\n   *\n   * Examples:\n   *\n   *    symbolicEqual('x*y', 'y*x') // true\n   *    symbolicEqual('x*y', 'y*x', {context: {multiply: {commutative: false}}})\n   *        //false\n   *    symbolicEqual('x/y', '(y*x^(-1))^(-1)') // true\n   *    symbolicEqual('abs(x)','x') // false\n   *    symbolicEqual('abs(x)','x', simplify.positiveContext) // true\n   *\n   * See also:\n   *\n   *    simplify, evaluate\n   *\n   * @param {Node|string} expr1  The first expression to compare\n   * @param {Node|string} expr2  The second expression to compare\n   * @param {Object} [options] Optional option object, passed to simplify\n   * @returns {boolean}\n   *     Returns true if a valid manipulation making the expressions equal\n   *     is found.\n   */\n  return typed(name, {\n    'string, string': function stringString(s1, s2) {\n      return this(parse(s1), parse(s2), {});\n    },\n    'string, string, Object': function stringStringObject(s1, s2, options) {\n      return this(parse(s1), parse(s2), options);\n    },\n    'Node, string': function NodeString(e1, s2) {\n      return this(e1, parse(s2), {});\n    },\n    'Node, string, Object': function NodeStringObject(e1, s2, options) {\n      return this(e1, parse(s2), options);\n    },\n    'string, Node': function stringNode(s1, e2) {\n      return this(parse(s1), e2, {});\n    },\n    'string, Node, Object': function stringNodeObject(s1, e2, options) {\n      return this(parse(s1), e2, options);\n    },\n    'Node, Node': function NodeNode(e1, e2) {\n      return this(e1, e2, {});\n    },\n    'Node, Node, Object': function NodeNodeObject(e1, e2, options) {\n      var diff = new OperatorNode('-', 'subtract', [e1, e2]);\n      var simplified = simplify(diff, {}, options);\n      return isConstantNode(simplified) && !simplified.value;\n    }\n  });\n});"],"mappings":"AAAA,SAASA,cAAc,QAAQ,mBAAmB;AAClD,SAASC,OAAO,QAAQ,wBAAwB;AAChD,IAAIC,IAAI,GAAG,eAAe;AAC1B,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,UAAU,EAAE,OAAO,EAAE,cAAc,CAAC;AACjE,OAAO,IAAIC,mBAAmB,GAAG,eAAeH,OAAO,CAACC,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EAClF,IAAI;IACFC,KAAK;IACLC,QAAQ;IACRC,KAAK;IACLC;EACF,CAAC,GAAGJ,IAAI;;EAER;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOG,KAAK,CAACN,IAAI,EAAE;IACjB,gBAAgB,EAAE,SAASQ,YAAY,CAACC,EAAE,EAAEC,EAAE,EAAE;MAC9C,OAAO,IAAI,CAACN,KAAK,CAACK,EAAE,CAAC,EAAEL,KAAK,CAACM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACvC,CAAC;IACD,wBAAwB,EAAE,SAASC,kBAAkB,CAACF,EAAE,EAAEC,EAAE,EAAEE,OAAO,EAAE;MACrE,OAAO,IAAI,CAACR,KAAK,CAACK,EAAE,CAAC,EAAEL,KAAK,CAACM,EAAE,CAAC,EAAEE,OAAO,CAAC;IAC5C,CAAC;IACD,cAAc,EAAE,SAASC,UAAU,CAACC,EAAE,EAAEJ,EAAE,EAAE;MAC1C,OAAO,IAAI,CAACI,EAAE,EAAEV,KAAK,CAACM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAChC,CAAC;IACD,sBAAsB,EAAE,SAASK,gBAAgB,CAACD,EAAE,EAAEJ,EAAE,EAAEE,OAAO,EAAE;MACjE,OAAO,IAAI,CAACE,EAAE,EAAEV,KAAK,CAACM,EAAE,CAAC,EAAEE,OAAO,CAAC;IACrC,CAAC;IACD,cAAc,EAAE,SAASI,UAAU,CAACP,EAAE,EAAEQ,EAAE,EAAE;MAC1C,OAAO,IAAI,CAACb,KAAK,CAACK,EAAE,CAAC,EAAEQ,EAAE,EAAE,CAAC,CAAC,CAAC;IAChC,CAAC;IACD,sBAAsB,EAAE,SAASC,gBAAgB,CAACT,EAAE,EAAEQ,EAAE,EAAEL,OAAO,EAAE;MACjE,OAAO,IAAI,CAACR,KAAK,CAACK,EAAE,CAAC,EAAEQ,EAAE,EAAEL,OAAO,CAAC;IACrC,CAAC;IACD,YAAY,EAAE,SAASO,QAAQ,CAACL,EAAE,EAAEG,EAAE,EAAE;MACtC,OAAO,IAAI,CAACH,EAAE,EAAEG,EAAE,EAAE,CAAC,CAAC,CAAC;IACzB,CAAC;IACD,oBAAoB,EAAE,SAASG,cAAc,CAACN,EAAE,EAAEG,EAAE,EAAEL,OAAO,EAAE;MAC7D,IAAIS,IAAI,GAAG,IAAId,YAAY,CAAC,GAAG,EAAE,UAAU,EAAE,CAACO,EAAE,EAAEG,EAAE,CAAC,CAAC;MACtD,IAAIK,UAAU,GAAGjB,QAAQ,CAACgB,IAAI,EAAE,CAAC,CAAC,EAAET,OAAO,CAAC;MAC5C,OAAOd,cAAc,CAACwB,UAAU,CAAC,IAAI,CAACA,UAAU,CAACC,KAAK;IACxD;EACF,CAAC,CAAC;AACJ,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}